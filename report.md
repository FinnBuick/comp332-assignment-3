# Macquarie University, Department of Computing
## COMP332 Programming Languages 2018
### Assignment 3
#### Finneas Buick 44604181

### Introduction

This goal of this assignment was to finish off our Lintilla compiler by implementing the final translation phase. This phase is responsible for translating the program tree generated by the syntax analysis phase into a series of SEC machine instructions that can be executed by the SEC machine given to us. We we're also required to design test cases to ensure that our implementation was working correctly.

This report describes the design and implementation of the translator as well as the design of the tests used to verify it's correctness.

### Translating Lintilla Expressions

To translate from Lintilla expressions to SEC machine instructions we employ Scala's powerful pattern matching mechanism. Since all of the unary Lintilla expressions have a directly correspondent SEC machine instruction, their translation is very simple. We use the `translateExp()` function in Translator.scala to handle translation of Lintilla expressions.

Consider an integer expression, all we must do is match to the `IntExp` case class along with it's contents, the literal integer value and then generate a `IInt()` SEC instruction with the corresponding value. Here the `gen()` function appends the instruction to the instruction buffer which essentially pushes the instruction onto the stack of the SEC machine.

```
case IntExp (i) =>
  gen (IInt (i))
```

This same pattern applies to all the other unary expressions with minor variations. IdnExp contain an IdnUse expression which must be decomposed to reach the encapsulated identifier string.

```
case IdnExp (IdnUse(i)) =>
  gen (IVar (i))
```

Also negation is handled the same way except the encapsulated integer value is negated.

```
case NegExp (IntExp(i)) =>
  gen (IInt (-i))
```

Arithmetic operations, equality and less-then comparisons work by translating their left and right operands and pushing them onto the stack and followed by the appropriate instruction. Taking the PlusExp as an example, we can translateExp recursively on the left expression then the right expression and finally push the `IAdd()` instruction.

```
case PlusExp (left, right) =>
  translateExp (left)
  translateExp (right)
  gen (IAdd ())
```

An `IfExp` works slightly differently since it must capture entire blocks of expressions to decide on control flow. To do this we have to translate the contents of each block into a list of instructions A.K.A frames. We then have to evaluate the condition and push that onto the stack and then finally generate the `IBranch` instruction containing the frames for true and false cases.

Lastly the function application expression known as `AppExp` works by translating the function arguments one after the other using Scala's inbuilt `map()` followed by an `ICall` instruction.

### Translating Sequences of Lintilla expressions

In order to translate sequence of expressions, we process them recursively by translating the first expression in the list and then recurse on the rest of the list using Scala's List tail-recursion mechanism `head :: tail` like so:

```
def translateSeq(list : List[Expression]) {
  list match {
      case (exp :: rest) =>
        translateExp(exp)
        translateSeq(rest)
      case _ => ()
  }
}
```

This will work for all the expressions except for `let` and `fn`, since we must bind them to an identifier so their scope can extend across the rest of the expressions in the sequence. To handle the `let` and `fn` expressions we must create some other cases.

For the `LetDecl` case we first translate the exp on the right hand side of the `=` and push that onto the stack, this represents the initial value of the variable. Then we translate the rest of the sequence and store it in a `val` called `frame` using the `translateToFrame()`. Now we are ready to construct the closure to bind the identifier so that it can be used later on as a variable. We pass in `None` for the function name option argument since this is not a function, followed by the translated `rest` sequence in `frame` with an appended `IPopEnv`.

```
case (LetDecl (IdnDef(idn), exp) :: rest) =>
  translateExp(exp)
  val frame = translateToFrame (rest)
  gen (IClosure (None, List (idn), frame :+ IPopEnv ()))
  gen (ICall())
```

For the `FnDecl` case we must push two closures onto the stack, one to implement the function and one to bind the identifier of the function to the first closure.

To create the first closure we simply pass in an option containing the identifier as the first argument. Next we must convert the `Vector` of `ParamDecl` objects into a list of identifier to do this we first convert the `Vector` to a `List` using the given `vecToList()` function. Then we use a `map` to decompose each of the elements into the identifier string.

```
val argNames = params.map({ case ParamDecl(IdnDef(i),_) => i })
```

Now we can pass this list of strings into the closures second argument. Then we translate the body of the function using `translateToFrame()` and pass that frame into the closures last argument, appending an `IPopEnv` instruction to pop the referencing environment off the stack to discard it after the closure executes. We now push that closure onto the stack.

```
gen (IClosure (Some (idn), argNames, closureBody :+ IPopEnv ()))
```

For the second binding closure we simply pass in the identifier and the subsequent translated code again followed by an `IPopEnv`.

```
val frameToBind = translateToFrame (rest)
gen (IClosure (None, List (idn), frameToBind :+ IPopEnv ()))
```

Lastly we push an `ICall()` instruction which pops the closure containing the function off the stack, followed by a closure for each of the parameters to the function.


### Testing

- explain goal
- outline methodology

Since it would be unreasonable to test every possible combination of translator, my main goal with testing was to ensure that each individual part of the translator was producing the correct translation. The main focus was target tree testing since it reduces ambiguity, i.e. its possible a translation could produce the correct output but the tree could be incorrect. however, execution tests were still used to verify correct execution outputs.

Starting with target tree testing, I began by testing singular expressions like integers and Boolean values making sure to test a range of different values. Here is an example of such tests.

```
test("printing a large negative integer gives the right translation") {
  targetTestInline("""
     |print(-1000000000)""".stripMargin,
                   List(IInt(0),IInt(1000000000), ISub(), IPrint()))
}
```


Then I moved on to translating larger constructs such as operations like addition, subtraction, division and multiplication.
