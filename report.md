# Macquarie University, Department of Computing
## COMP332 Programming Languages 2018
### Assignment 3
#### Finneas Buick 44604181

### Introduction

This goal of this assignment was to finish off our Lintilla compiler by implementing the final translation phase. This phase is responsible for translating the program tree generated by the syntax analysis phase into a series of SEC machine instructions that can be executed by the SEC machine given to us. We we're also required to design test cases to ensure that our implementation was working correctly.

This report describes the design and implementation of the translator as well as the design of the tests used to verify it's correctness.

### Translating Lintilla Expressions

To translate from Lintilla expressions to SEC machine instructions we employ Scala's powerful pattern matching mechanism. Since all of the unary Lintilla expressions have a directly correspondent SEC machine instruction, their translation is very simple. We use the `translateExp()` function in Translator.scala to handle translation of Lintilla expressions.

Consider an integer expression, all we must do is match to the `IntExp` case class along with it's contents, the literal integer value and then generate a `IInt()` SEC instruction with the corresponding value. Here the `gen()` function appends the instruction to the instruction buffer which essentially pushes the instruction onto the stack of the SEC machine.

```
case IntExp (i) =>
  gen (IInt (i))
```

This same pattern applies to all the other unary expressions with minor variations. IdnExp contain an IdnUse expression which must be decomposed to reach the encapsulated identifier string.

```
case IdnExp (IdnUse(i)) =>
  gen (IVar (i))
```

Also negation is handled the same way except the encapsulated integer value is negated.

```
case NegExp (IntExp(i)) =>
  gen (IInt (-i))
```

Arithmetic operations, equality and less-then comparisons work by translating their left and right operands and pushing them onto the stack and followed by the appropriate instruction. Taking the PlusExp as an example, we can translateExp recursively on the left expression then the right expression and finally push the `IAdd()` instruction.

```
case PlusExp (left, right) =>
  translateExp (left)
  translateExp (right)
  gen (IAdd ())
```
